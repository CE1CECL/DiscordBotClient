<!DOCTYPE html>
<html>

<head>
        <meta charset="utf-8" />
        <meta content="width=device-width, initial-scale=1.0, maximum-scale=3.0" name="viewport" />

        <!-- section:seometa -->
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="Discord" />
        <meta property="og:title" content="Discord - A New Way to Chat with Friends & Communities" />
        <meta property="og:description"
                content="Discord is the easiest way to communicate over voice, video, and text.  Chat, hang out, and stay close with your friends and communities." />
        <meta property="og:image" content="https://discord.com/assets/652f40427e1f5186ad54836074898279.png" />
        <link rel="icon" href="/assets/ec2c34cadd4b5f4594415127380a85e6.ico">
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:site" content="@discord" />
        <meta name="twitter:creator" content="@discord" />
        <!-- endsection -->
        <script>
                window.__OVERLAY__ = /overlay/.test(location.pathname);
                window.__BILLING_STANDALONE__ = /^\/billing/.test(location.pathname);
                window.GLOBAL_ENV = {
                        API_ENDPOINT: '//' + window.location.host + '/d/api',
                        API_VERSION: 9,
                        GATEWAY_ENDPOINT: 'wss://gateway.discord.gg',
                        // 'ws://' + window.location.host,
                        RELEASE_CHANNEL: 'stable',
                        HTML_TIMESTAMP: Date.now(),
                        ALGOLIA_KEY: 'aca0d7082e4e63af5ba5917d5e96bed0',
                        WEBAPP_ENDPOINT: "//" + window.location.host,
                        CDN_HOST: 'cdn.discordapp.com',
                        ASSET_ENDPOINT: "//" + window.location.host,
                        MEDIA_PROXY_ENDPOINT: '//media.discordapp.net',
                        WIDGET_ENDPOINT: '//discord.com/widget',
                        INVITE_HOST: 'discord.gg',
                        GUILD_TEMPLATE_HOST: 'discord.new',
                        GIFT_CODE_HOST: 'discord.gift',
                        MARKETING_ENDPOINT: '//discord.com',
                        BRAINTREE_KEY: 'production_5st77rrc_49pp2rp4phym7387',
                        STRIPE_KEY: 'pk_live_CUQtlpQUF0vufWpnpUmQvcdi',
                        NETWORKING_ENDPOINT: '//router.discordapp.net',
                        RTC_LATENCY_ENDPOINT: '//latency.discord.media/rtc',
                        ACTIVITY_APPLICATION_HOST: 'discordsays.com',
                        PROJECT_ENV: 'production',
                        REMOTE_AUTH_ENDPOINT: '//remote-auth-gateway.discord.gg',
                        SENTRY_TAGS: { "buildId": "7956ae0a7fef17564b5e718757ad1a38d2322063", "buildType": "normal" },
                        MIGRATION_SOURCE_ORIGIN: 'https://discord.com',
                        MIGRATION_DESTINATION_ORIGIN: window.location.protocol + "//" + window.location.host,
                };
                Object.defineProperty(window, "localStorage_", {
                        value: window.localStorage
                });
                const localStorage = window.localStorage;
                var getModule;
                var findModule;
                var loadFullGuild = 0;
                var allGuild = 0;
                var intentBot = localStorage_.getItem("intents");
                const IntentFlags = {
                        GUILDS: 1 << 0,
                        GUILD_MEMBERS: 1 << 1,
                        GUILD_BANS: 1 << 2,
                        GUILD_EMOJIS_AND_STICKERS: 1 << 3,
                        GUILD_INTEGRATIONS: 1 << 4,
                        GUILD_WEBHOOKS: 1 << 5,
                        GUILD_INVITES: 1 << 6,
                        GUILD_VOICE_STATES: 1 << 7,
                        GUILD_PRESENCES: 1 << 8,
                        GUILD_MESSAGES: 1 << 9,
                        GUILD_MESSAGE_REACTIONS: 1 << 10,
                        GUILD_MESSAGE_TYPING: 1 << 11,
                        DIRECT_MESSAGES: 1 << 12,
                        DIRECT_MESSAGE_REACTIONS: 1 << 13,
                        DIRECT_MESSAGE_TYPING: 1 << 14,
                        MESSAGE_CONTENT: 1 << 15,
                        GUILD_SCHEDULED_EVENTS: 1 << 16,
                        // https://discord.com/developers/docs/topics/gateway#list-of-intents
                        AUTO_MODERATION_CONFIGURATION: 1 << 20,
                        AUTO_MODERATION_EXECUTION: 1 << 21,
                };
                const getIntents = (...removeIntents) => Object.values(IntentFlags).reduce((a, b) => a + b) - (removeIntents.flat(2).map(name => IntentFlags[name] || 0).reduce((a, b) => a + b, 0) || 0);
                var callSetIntents = () => {
                        const privilegedIntents = [];
                        alert("Login with bot requires privileged intent `MESSAGE_CONTENT`\n\nMake sure you have enabled this intent in the bot settings.");
                        if (!confirm('[Optional] Do you want to use the `GUILD_PRESENCES` intent?')) {
                                privilegedIntents.push('GUILD_PRESENCES');
                        }
                        if (!confirm('[Optional] Do you want to use the `GUILD_MEMBERS` intent?')) {
                                privilegedIntents.push('GUILD_MEMBERS');
                        }
                        intentBot = getIntents(...privilegedIntents);
                        localStorage_.setItem('intents', intentBot);
                }
        </script>
</head>

<body>
        <div id="app-mount"></div>
        <script src="/assets/9af08cab5ec8da0028ac.js"></script>
        <script src="/assets/12ce378cc6190128aac5.js"></script>
        <script src="/assets/180d44fd394555f21790.js"></script>
        <script src="/assets/02be0d5b4681a76d9def.js"></script>
        <script>
                window.onload = function () {
                        getModule = (n, f = true) => { // 'f' is whether to return the first module found if it goes by display name
                                const cache = () => {
                                        let webp = window.webpackChunkdiscord_app.push([
                                                [Symbol()], {},
                                                _ => _.c
                                        ]);
                                        window.webpackChunkdiscord_app.pop();
                                        return webp;
                                };
                                let findAllModules = (filter = (m) => m) => {
                                        let modules = [];
                                        for (let item in cache()) {
                                                if (Object.hasOwnProperty.call(cache(), item)) {
                                                        let element = cache()[item].exports;
                                                        if (!element) {
                                                                continue
                                                        }
                                                        if (filter(element)) {
                                                                modules.push(element)
                                                        }
                                                }
                                        }
                                        return modules
                                };
                                let x = false;
                                let mod;
                                window.webpackChunkdiscord_app.push([
                                        [Math.random()], {}, (e) => {
                                                mod = mod || Object.values(e.c).find(m => m?.exports?.Z?.[n]);
                                        }
                                ]);
                                window.webpackChunkdiscord_app.pop();
                                if (typeof mod === "undefined") {
                                        window.webpackChunkdiscord_app.push([
                                                [Math.random()], {}, (e) => {
                                                        mod = mod || Object.values(e.c).find(m => m?.exports?.[n]);
                                                }
                                        ]);
                                        window.webpackChunkdiscord_app.pop();
                                }
                                if (typeof mod === "undefined") {
                                        x = true;
                                        if (f == true) {
                                                mod = mod || (typeof findAllModules(m => m?.Z?.displayName === n) !== "undefined") ? findAllModules(m => m?.Z?.displayName === n)?.[0] : findAllModules(m => m?.displayName === n)?.[0];
                                        } else {
                                                mod = mod || (typeof findAllModules(m => m?.Z?.displayName === n) !== "undefined") ? findAllModules(m => m?.Z?.displayName === n) : findAllModules(m => m?.displayName === n);
                                        }
                                }
                                if (x) {
                                        return (typeof mod?.Z !== "undefined") ? mod?.Z : mod;
                                }
                                else if (x == false) {
                                        return (typeof mod?.exports?.Z !== "undefined") ? mod?.exports?.Z : mod?.exports;
                                }
                                return undefined;
                        }
                        findModule = (n, b) => {
                                (d = typeof b === "undefined" ? true : b,
                                        n = n.toLowerCase(),
                                        m = []);
                                webpackChunkdiscord_app.push([
                                        [Math.random()], {},
                                        (e) => {
                                                m.push(...Object.values(e.c).filter(m => m?.exports && ((m?.exports?.Z && Object.keys(m.exports.Z).some(key => key.toLowerCase().includes(n))) || (m.exports?.Z?.prototype && Object.keys(m.exports.Z.prototype).some(key => key.toLowerCase().includes(n))) || Object.keys(m.exports).some(key => key.toLowerCase().includes(n)))))
                                        }
                                ]);
                                webpackChunkdiscord_app.pop();
                                if (d) {
                                        m.forEach(f => m.push(typeof f?.exports?.Z === "undefined" ? f?.exports : f?.exports?.Z));
                                        for (var i = 0; i < m.length; i++) {
                                                m.forEach((f, i) => typeof f?.id === "undefined" ? m = m : m.splice(i, 1));
                                        }
                                        return [...m].filter(m => m?.Window?.name !== "Window");
                                } else {
                                        return [...m].filter(m => m?.Window?.name !== "Window");
                                };
                        }
                };
                i = setInterval(() => {
                        let buttonLogin = document.getElementsByClassName("marginBottom8-emkd0_ button-1cRKG6 button-f2h6uQ lookFilled-yCfaCM colorBrand-I6CyqQ sizeLarge-3mScP9 fullWidth-fJIsjq grow-2sR_-F")[0];
                        if (buttonLogin) {
                                buttonLogin.addEventListener("click", () => {
                                        const input = document.getElementsByClassName("inputDefault-3FGxgL input-2g-os5")[0];
                                        getModule('loginToken').loginToken(input.value);
                                });

                                const email = document.getElementsByClassName("marginBottom20-315RVT")[0];
                                email.parentElement.removeChild(email);

                                const input_ = document.getElementsByClassName("label-2bTGzo title-3hptVQ defaultColor-2cKwKo defaultMarginlabel-1h4HPn")[0]

                                input_.innerHTML = "Token";
                                input_.id = "token";

                                const QR = document.getElementsByClassName("transitionGroup-bPT0qU qrLogin-1ejtpI")[0];
                                QR.parentElement.removeChild(QR);

                                const dot = document.getElementsByClassName("verticalSeparator-2r9gHa")[0];
                                dot.parentElement.removeChild(dot);
                                clearInterval(i);

                                if (!intentBot) {
                                        callSetIntents();
                                } else if (confirm(`Do you want to set new intents?\nOld intents: ${intentBot}`)) {
                                        callSetIntents();
                                }
                        }
                }, 250);
        </script>
        <script>
                // Embed script
                // MessageEmbed v13

                const Colors = {
                        DEFAULT: 0x000000,
                        WHITE: 0xffffff,
                        AQUA: 0x1abc9c,
                        GREEN: 0x57f287,
                        BLUE: 0x3498db,
                        YELLOW: 0xfee75c,
                        PURPLE: 0x9b59b6,
                        LUMINOUS_VIVID_PINK: 0xe91e63,
                        FUCHSIA: 0xeb459e,
                        GOLD: 0xf1c40f,
                        ORANGE: 0xe67e22,
                        RED: 0xed4245,
                        GREY: 0x95a5a6,
                        NAVY: 0x34495e,
                        DARK_AQUA: 0x11806a,
                        DARK_GREEN: 0x1f8b4c,
                        DARK_BLUE: 0x206694,
                        DARK_PURPLE: 0x71368a,
                        DARK_VIVID_PINK: 0xad1457,
                        DARK_GOLD: 0xc27c0e,
                        DARK_ORANGE: 0xa84300,
                        DARK_RED: 0x992d22,
                        DARK_GREY: 0x979c9f,
                        DARKER_GREY: 0x7f8c8d,
                        LIGHT_GREY: 0xbcc0c0,
                        DARK_NAVY: 0x2c3e50,
                        BLURPLE: 0x5865f2,
                        GREYPLE: 0x99aab5,
                        DARK_BUT_NOT_BLACK: 0x2c2f33,
                        NOT_QUITE_BLACK: 0x23272a,
                }

                function cloneObject(obj) {
                        return Object.assign(Object.create(obj), obj);
                }

                function resolveColor(color) {
                        if (typeof color === 'string') {
                                if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));
                                if (color === 'DEFAULT') return 0;
                                color = Colors[color] ?? parseInt(color.replace('#', ''), 16);
                        } else if (Array.isArray(color)) {
                                color = (color[0] << 16) + (color[1] << 8) + color[2];
                        }

                        if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');
                        else if (Number.isNaN(color)) throw new TypeError('COLOR_CONVERT');

                        return color;
                }

                class MessageEmbed {
                        constructor(data = {}, skipValidation = false) {
                                this.setup(data, skipValidation);
                        }

                        setup(data, skipValidation) {
                                this.type = data.type ?? 'rich';

                                this.title = data.title ?? null;

                                this.description = data.description ?? null;

                                this.url = data.url ?? null;

                                this.color = 'color' in data ? resolveColor(data.color) : null;

                                this.timestamp = 'timestamp' in data ? new Date(data.timestamp).getTime() : null;

                                this.fields = [];
                                if (data.fields) {
                                        this.fields = skipValidation ? data.fields.map(cloneObject) : this.constructor.normalizeFields(data.fields);
                                }

                                this.thumbnail = data.thumbnail
                                        ? {
                                                url: data.thumbnail.url,
                                                proxyURL: data.thumbnail.proxyURL ?? data.thumbnail.proxy_url,
                                                height: data.thumbnail.height,
                                                width: data.thumbnail.width,
                                        }
                                        : null;

                                this.image = data.image
                                        ? {
                                                url: data.image.url,
                                                proxyURL: data.image.proxyURL ?? data.image.proxy_url,
                                                height: data.image.height,
                                                width: data.image.width,
                                        }
                                        : null;

                                this.video = data.video
                                        ? {
                                                url: data.video.url,
                                                proxyURL: data.video.proxyURL ?? data.video.proxy_url,
                                                height: data.video.height,
                                                width: data.video.width,
                                        }
                                        : null;

                                this.author = data.author
                                        ? {
                                                name: data.author.name,
                                                url: data.author.url,
                                                iconURL: data.author.iconURL ?? data.author.icon_url,
                                                proxyIconURL: data.author.proxyIconURL ?? data.author.proxy_icon_url,
                                        }
                                        : null;

                                this.provider = data.provider
                                        ? {
                                                name: data.provider.name,
                                                url: data.provider.url,
                                        }
                                        : null;

                                this.footer = data.footer
                                        ? {
                                                text: data.footer.text,
                                                iconURL: data.footer.iconURL ?? data.footer.icon_url,
                                                proxyIconURL: data.footer.proxyIconURL ?? data.footer.proxy_icon_url,
                                        }
                                        : null;
                        }

                        get createdAt() {
                                return this.timestamp ? new Date(this.timestamp) : null;
                        }

                        get hexColor() {
                                return this.color ? `#${this.color.toString(16).padStart(6, '0')}` : null;
                        }

                        get length() {
                                return (
                                        (this.title?.length ?? 0) +
                                        (this.description?.length ?? 0) +
                                        (this.fields.length >= 1
                                                ? this.fields.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0)
                                                : 0) +
                                        (this.footer?.text.length ?? 0) +
                                        (this.author?.name.length ?? 0)
                                );
                        }

                        equals(embed) {
                                return (
                                        this.type === embed.type &&
                                        this.author?.name === embed.author?.name &&
                                        this.author?.url === embed.author?.url &&
                                        this.author?.iconURL === (embed.author?.iconURL ?? embed.author?.icon_url) &&
                                        this.color === embed.color &&
                                        this.title === embed.title &&
                                        this.description === embed.description &&
                                        this.url === embed.url &&
                                        this.timestamp === embed.timestamp &&
                                        this.fields.length === embed.fields.length &&
                                        this.fields.every((field, i) => this._fieldEquals(field, embed.fields[i])) &&
                                        this.footer?.text === embed.footer?.text &&
                                        this.footer?.iconURL === (embed.footer?.iconURL ?? embed.footer?.icon_url) &&
                                        this.image?.url === embed.image?.url &&
                                        this.thumbnail?.url === embed.thumbnail?.url &&
                                        this.video?.url === embed.video?.url &&
                                        this.provider?.name === embed.provider?.name &&
                                        this.provider?.url === embed.provider?.url
                                );
                        }

                        _fieldEquals(field, other) {
                                return field.name === other.name && field.value === other.value && field.inline === other.inline;
                        }

                        addField(name, value, inline) {
                                return this.addFields({ name, value, inline });
                        }

                        addFields(...fields) {
                                this.fields.push(...this.constructor.normalizeFields(fields));
                                return this;
                        }

                        spliceFields(index, deleteCount, ...fields) {
                                this.fields.splice(index, deleteCount, ...this.constructor.normalizeFields(...fields));
                                return this;
                        }

                        setFields(...fields) {
                                this.spliceFields(0, this.fields.length, fields);
                                return this;
                        }

                        setAuthor(options, deprecatedIconURL, deprecatedURL) {
                                if (options === null) {
                                        this.author = {};
                                        return this;
                                }

                                if (typeof options === 'string') {
                                        options = { name: options, url: deprecatedURL, iconURL: deprecatedIconURL };
                                }

                                const { name, url, iconURL } = options;
                                this.author = { name, url, iconURL };
                                return this;
                        }

                        setColor(color) {
                                this.color = resolveColor(color);
                                return this;
                        }

                        setDescription(description) {
                                this.description = description;
                                return this;
                        }

                        setFooter(options, deprecatedIconURL) {
                                if (options === null) {
                                        this.footer = undefined;
                                        return this;
                                }

                                if (typeof options === 'string') {
                                        options = { text: options, iconURL: deprecatedIconURL };
                                }

                                const { text, iconURL } = options;
                                this.footer = { text, iconURL };
                                return this;
                        }

                        setImage(url) {
                                this.image = { url };
                                return this;
                        }

                        setThumbnail(url) {
                                this.thumbnail = { url };
                                return this;
                        }

                        setTimestamp(timestamp = Date.now()) {
                                if (timestamp instanceof Date) timestamp = timestamp.getTime();
                                this.timestamp = timestamp;
                                return this;
                        }

                        setTitle(title) {
                                this.title = title;
                                return this;
                        }

                        setURL(url) {
                                this.url = url;
                                return this;
                        }

                        toJSON() {
                                return {
                                        title: this.title,
                                        type: 'rich',
                                        description: this.description,
                                        url: this.url,
                                        timestamp: this.timestamp && new Date(this.timestamp),
                                        color: this.color,
                                        fields: this.fields,
                                        thumbnail: this.thumbnail,
                                        image: this.image,
                                        author: this.author && {
                                                name: this.author.name,
                                                url: this.author.url,
                                                icon_url: this.author.iconURL,
                                        },
                                        footer: this.footer && {
                                                text: this.footer.text,
                                                icon_url: this.footer.iconURL,
                                        },
                                };
                        }

                        static normalizeField(name, value, inline = false) {
                                return {
                                        name,
                                        value,
                                        inline,
                                };
                        }

                        static normalizeFields(...fields) {
                                return fields
                                        .flat(2)
                                        .map(field =>
                                                this.normalizeField(field.name, field.value, typeof field.inline === 'boolean' ? field.inline : false),
                                        );
                        }
                }
        </script>
        <script>
                // Send Message
                function sendMessage(options) {
                        if (typeof options !== 'object') {
                                options = {
                                        content: `${options}`,
                                };
                        }
                        let { content, embeds } = options;
                        if (!Array.isArray(embeds)) embeds = [];
                        const msgObject = {
                                content,
                                embeds: embeds.map(embed => {
                                        if (embed instanceof MessageEmbed) return embed.toJSON();
                                        return embed;
                                }) || [],
                        }
                        if (typeof getModule !== 'function') return console.log('No getModule');
                        let token = getModule('getToken').getToken();
                        let channelId = getModule('getChannelId').getChannelId()
                        if (!token) throw new Error('No token');
                        if (!channelId) throw new Error('Channel not found');
                        if (embeds.length === 0 && !content) throw new Error('No content or embeds');
                        if (embeds.length > 10) throw new Error('Too many embeds');
                        if (content?.length > 2000) throw new Error('Content too long');
                        // Send message
                        return new Promise((resolve, reject) => {
                                fetch(`https://discord.com/api/v9/channels/${channelId}/messages`, {
                                        method: 'POST',
                                        headers: {
                                                'Content-Type': 'application/json',
                                                'Authorization': `Bot ${token}`,
                                        },
                                        body: JSON.stringify(msgObject),
                                })
                                        .then(res => res.json())
                                        .then(resolve)
                                        .catch(reject);
                        })
                }
        </script>
</body>

</html>